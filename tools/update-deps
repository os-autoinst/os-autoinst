#!/usr/bin/env perl
use strict;
use warnings;
use 5.010;

use YAML::PP;
use Data::Dumper;
use Mojo::File qw(path);
use Getopt::Long;
use FindBin qw($Bin);
use File::Spec;

GetOptions(
    "help|h" => \my $help,
    "specfile=s" => \my $specfile,
    "dockerfile=s" => \my $dockerfile,
);

usage(0) if $help;
usage(1) unless $specfile;

my $scriptname   = File::Spec->canonpath(__FILE__);
my $yamlfile     = "dependencies.yaml";
my $file         = "$Bin/../$yamlfile";
my $cpanfile     = "$Bin/../cpanfile";

my $data     = YAML::PP->new->load_file($file);
my $spec     = path($specfile)->slurp;

my $spectargets   = $data->{targets}->{spec};
my $cpantargets   = $data->{targets}->{cpanfile};
my $dockertargets = $data->{targets}->{docker};

my ($modules, $test_modules, $cover_modules, $devel_modules) = get_modules();

update_spec();
update_cpanfile($modules, $test_modules, $cover_modules, $devel_modules);
update_dockerfile() if $dockerfile;

sub update_dockerfile {
    my $docker = path($dockerfile)->slurp;
    my @perl;
    my @pkg;
    for my $target (@$dockertargets) {
        my $name = $target . '_requires';
        if ($target eq 'requires') {
            $name = 'requires';
        }
        my $deps     = $data->{$name};
        for my $key (sort keys %$deps) {
            next if $key =~ m/^%/;
            my $line = '       ';

            if ($key =~ m/\(/) {
                $key = "'$key'";
            }
            $line .= $key;
            $line .= " \\\n";
            if ($key =~ m/perl\(/) {
                push @perl, $line;
            }
            else {
                push @pkg, $line;
            }
        }
    }
    @perl = sort @perl;
    @pkg = sort @pkg;
    my $dep = join '', @pkg, @perl;
    my $begin = '# AUTODEPS START';
    my $end = '# AUTODEPS END';
    my $run = <<"EOM";
# This part is autogenerated by $scriptname from $yamlfile
RUN zypper in -y -C \\
$dep   && true
EOM
    $docker =~ s/($begin\n)(.*)($end\n)/$1$run$3/s;
    path($dockerfile)->spurt($docker);
    say "Updated $dockerfile";
}

sub update_spec {

    for my $target (@$spectargets) {
        my $name = $target . '_requires';
        if ($target eq 'requires') {
            $name = 'requires';
        }
        my $deps     = $data->{$name};
        my $prefix   = "%define $name";
        my $specline = $prefix;
        for my $key (sort keys %$deps) {
            my $version = $deps->{$key};
            if (ref $version) {
                $version = $version->{rpm};
            }
            $specline .= " $key";
            if ($key eq 'perl(Perl::Tidy)') {
                undef $version;
            }
            if ($version) {
                $specline .= " $version";
            }
        }
        my $comment = "# The following line is generated from $yamlfile";
        if ($spec =~ s/^# .*generated.*\n^$prefix.*/$comment\n$specline/m) {
            next;
        }
        # No comment above the line yet
        unless ($spec =~ s/^$prefix.*/$comment\n$specline/m) {
            die "/^$prefix/ not found in $specfile";
        }
    }

    path($specfile)->spurt($spec);
    say "Updated $specfile";
}

sub get_modules {

    my (%modules, %test, %cover, %devel);
    for my $target (@$cpantargets) {
        my $name = $target . '_requires';
        if ($target eq 'requires') {
            $name = 'requires';
        }
        my $deps = $data->{$name};
        for my $key (keys %$deps) {
            my $module = $key;
            next unless $module =~ s/^perl\((.*)\)$/$1/;
            my $version = $deps->{$key};
            if (ref $version) {
                $version = $version->{perl};
            }
            if ($target eq 'test') {
                $test{$module} = $version;
            }
            elsif ($target eq 'cover') {
                $cover{$module} = $version;
            }
            elsif ($target eq 'devel') {
                $devel{$module} = $version;
            }
            else {
                $modules{$module} = $version;
            }
        }
    }
    return (\%modules, \%test, \%cover, \%devel);
}

sub _requires_line {
    # requires 'Archive::Extract', '> 0.7';
    my ($hash, $module) = @_;
    my $version = $hash->{$module};
    my $line    = "requires '$module'";
    $line .= qq{, '$version'} if $version;
    $line .= ";\n";
    return $line;
}

sub update_cpanfile {
    my ($modules, $test, $cover, $devel) = @_;
    my $cpan = <<"EOM";
##################################################
# WARNING
# This file is autogenerated by $scriptname
# from $yamlfile
##################################################

EOM
    for my $module (sort keys %$modules) {
        $cpan .= _requires_line($modules, $module);
    }
    my $test_requires = '';
    for my $module (sort keys %$test) {
        $test_requires .= '    ' . _requires_line($test, $module);
    }
    my $cover_requires = '';
    for my $module (sort keys %$cover) {
        $cover_requires .= '    ' . _requires_line($cover, $module);
    }
    my $devel_requires = '';
    for my $module (sort keys %$devel) {
        $devel_requires .= '    ' . _requires_line($devel, $module);
    }
    $cpan .= <<"EOM";

on 'test' => sub {
$test_requires
};

on 'devel' => sub {
$devel_requires
};

feature 'coverage', 'coverage for CI' => sub {
$cover_requires
};
EOM

    path($cpanfile)->spurt($cpan);
    say "Updated $cpanfile";
}

sub usage {
    my ($exit) = @_;
    print <<"EOM";
Usage:
    # update cpanfile and dist/rpm/os-autoinst.spec
    $0
    $0 --specfile dist/rpm/os-autoinst.spec
    $0 --dockerfile docker/travis_test/Dockerfile
EOM
    exit $exit;
}
